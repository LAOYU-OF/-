<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‡å®™æ‰‹åŠ¿ç²’å­ç³»ç»Ÿ</title>
    <!-- å¼•å…¥ MediaPipe Hands å’Œ Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #video-input {
            display: none; /* éšè—åŸå§‹è§†é¢‘æµ */
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: rgba(255, 255, 255, 0.8);
            pointer-events: none;
        }
        h1 {
            font-size: 1.5rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 10px #00ffff;
        }
        p {
            font-size: 0.9rem;
            margin: 5px 0;
        }
        .status {
            color: #00ff00;
            font-weight: bold;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            z-index: 20;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Cosmos Hand Control</h1>
        <p>çŠ¶æ€: <span id="status-text" style="color: yellow;">åˆå§‹åŒ–ä¸­...</span></p>
        <p>æ“ä½œæŒ‡å—:</p>
        <p>ğŸ–ï¸ <b>ç§»åŠ¨æ‰‹æŒ</b>: æ‰°åŠ¨æ˜Ÿäº‘</p>
        <p>â˜ï¸ <b>é£ŸæŒ‡æåˆ</b>: äº§ç”Ÿé»‘æ´å¼•åŠ›</p>
        <p>âœŒï¸ <b>åŒæ‰‹å±•ç¤º</b>: è¿æ¥æ˜Ÿç³»</p>
    </div>

    <div id="loading">
        æ­£åœ¨åŠ è½½ AI æ¨¡å‹å’Œæ‘„åƒå¤´...<br>
        è¯·å…è®¸æµè§ˆå™¨è®¿é—®æ‘„åƒå¤´æƒé™ã€‚
    </div>

    <video id="video-input"></video>
    <canvas id="output-canvas"></canvas>

    <script>
        // --- é…ç½®å‚æ•° ---
        const PARTICLE_COUNT = 2000;
        const CONNECTION_DISTANCE = 100;
        const MOUSE_INFLUENCE_RADIUS = 250;
        const COLORS = ['#1E90FF', '#00BFFF', '#87CEFA', '#E0FFFF', '#9370DB', '#BA55D3', '#FF69B4'];

        // --- å®‡å®™çŠ¶æ€ ---
        const STATE_CHAOS = 0;    // æ··æ²Œ/å¥‡ç‚¹
        const STATE_EXPLODING = 1; // å¤§çˆ†ç‚¸
        const STATE_GALAXY = 2;    // é“¶æ²³ç³»
        let systemState = STATE_CHAOS;

        // --- å˜é‡åˆå§‹åŒ– ---
        const canvas = document.getElementById('output-canvas');
        const ctx = canvas.getContext('2d');
        const videoElement = document.getElementById('video-input');
        const statusText = document.getElementById('status-text');
        const loadingDiv = document.getElementById('loading');

        let width, height;
        let particles = [];
        let handLandmarks = []; // å­˜å‚¨æ£€æµ‹åˆ°çš„æ‰‹éƒ¨å…³é”®ç‚¹
        let isPinching = false; // æ˜¯å¦æåˆ

        // --- ç²’å­ç±» ---
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                if (systemState === STATE_CHAOS) {
                    // åˆå§‹åœ¨ä¸­å¿ƒå¥‡ç‚¹
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.random() * 20; // å¾ˆå°çš„åŠå¾„
                    this.x = width / 2 + Math.cos(angle) * r;
                    this.y = height / 2 + Math.sin(angle) * r;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                } else {
                    this.x = Math.random() * width;
                    this.y = Math.random() * height;
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = (Math.random() - 0.5) * 0.5;
                }
                
                this.size = Math.random() * 2 + 0.5;
                this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                this.baseX = this.x;
                this.baseY = this.y;
                this.density = (Math.random() * 30) + 1;
                this.friction = 0.95; // æ‘©æ“¦åŠ›
            }

            update() {
                if (systemState === STATE_CHAOS) {
                    // å¥‡ç‚¹çº¦æŸï¼šå¼ºåŠ›æ‹‰å›ä¸­å¿ƒ
                    const dx = width / 2 - this.x;
                    const dy = height / 2 - this.y;
                    this.vx += dx * 0.05;
                    this.vy += dy * 0.05;
                    
                    // å‰§çƒˆçƒ­è¿åŠ¨
                    this.vx += (Math.random() - 0.5) * 2;
                    this.vy += (Math.random() - 0.5) * 2;
                    
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // å¼ºé˜»å°¼é˜²æ­¢é£å‡º
                    this.vx *= 0.8;
                    this.vy *= 0.8;

                } else if (systemState === STATE_EXPLODING) {
                    // çº¯æƒ¯æ€§é£è¡Œï¼Œæ— é˜»åŠ›æˆ–å¾ˆå°é˜»åŠ›
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx *= 0.99;
                    this.vy *= 0.99;

                } else if (systemState === STATE_GALAXY) {
                    // é“¶æ²³ç³»åŠ¨åŠ›å­¦ (æ›´çœŸå®çš„å¼•åŠ›æ¨¡å‹)
                    const dx = width / 2 - this.x;
                    const dy = height / 2 - this.y;
                    const distSq = dx * dx + dy * dy;
                    const dist = Math.sqrt(distSq);
                    const angle = Math.atan2(dy, dx);
                    
                    // ä¸‡æœ‰å¼•åŠ› F = G * M / r^2
                    // è½¯åŒ–å› å­ 1000 é˜²æ­¢è¿‡è¿‘æ—¶åŠ›è¿‡å¤§
                    const force = 1000 / (distSq + 1000); 
                    
                    this.vx += Math.cos(angle) * force;
                    this.vy += Math.sin(angle) * force;

                    // æ‰‹åŠ¿äº¤äº’
                    this.handleInteraction();

                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // çœŸç©ºé˜»åŠ›æå°
                    this.vx *= 0.995; 
                    this.vy *= 0.995;
                }

                // è¾¹ç•Œæ£€æŸ¥ (ä»…åœ¨éçˆ†ç‚¸çŠ¶æ€ä¸‹é‡ç½®ï¼Œæˆ–è€…è®©å®ƒä»¬åå¼¹)
                if (systemState !== STATE_EXPLODING && systemState !== STATE_CHAOS) {
                     if (systemState === STATE_GALAXY) {
                         const margin = 100;
                         if (this.x < -margin || this.x > width + margin || this.y < -margin || this.y > height + margin) {
                            // é‡ç”Ÿ
                            const angle = Math.random() * Math.PI * 2;
                            const r = Math.random() * (Math.min(width, height) / 2);
                            this.x = width / 2 + Math.cos(angle) * r;
                            this.y = height / 2 + Math.sin(angle) * r;
                            
                            // èµ‹äºˆè½¨é“é€Ÿåº¦
                            const speed = Math.sqrt(20000 / (r + 10));
                            this.vx = Math.cos(angle + Math.PI / 2) * speed;
                            this.vy = Math.sin(angle + Math.PI / 2) * speed;
                         }
                     }
                }
            }

            handleInteraction() {
                 if (handLandmarks.length > 0) {
                    handLandmarks.forEach(hand => {
                        const indexFinger = hand[8];
                        const thumb = hand[4];
                        const handX = (1 - indexFinger.x) * width;
                        const handY = indexFinger.y * height;
                        
                        // è®¡ç®—æåˆ
                        const pinchDist = Math.hypot(
                            (1 - indexFinger.x) - (1 - thumb.x),
                            indexFinger.y - thumb.y
                        );
                        const isHandPinching = pinchDist < 0.05; 

                        const dx = handX - this.x;
                        const dy = handY - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < MOUSE_INFLUENCE_RADIUS) {
                            const forceDirectionX = dx / distance;
                            const forceDirectionY = dy / distance;
                            let force = (MOUSE_INFLUENCE_RADIUS - distance) / MOUSE_INFLUENCE_RADIUS;

                            if (isHandPinching) {
                                // é»‘æ´å¼•åŠ›
                                this.vx += forceDirectionX * force * 2;
                                this.vy += forceDirectionY * force * 2;
                            } else {
                                // æ‰°åŠ¨
                                this.vx -= forceDirectionX * force * 1;
                                this.vy -= forceDirectionY * force * 1;
                            }
                        }
                    });
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                
                if (systemState === STATE_CHAOS) {
                     ctx.fillStyle = '#FFFFFF';
                     ctx.shadowBlur = 20;
                     ctx.shadowColor = '#00FFFF';
                } else if (systemState === STATE_GALAXY) {
                     // æ ¹æ®è·ç¦»ä¸­å¿ƒçš„è¿œè¿‘è°ƒæ•´é¢œè‰²
                     const dx = width / 2 - this.x;
                     const dy = height / 2 - this.y;
                     const dist = Math.sqrt(dx*dx + dy*dy);
                     
                     // ä¸­å¿ƒæ›´äº®/ç™½ï¼Œè¾¹ç¼˜ä¿æŒåŸè‰²
                     if (dist < 100) {
                         ctx.fillStyle = '#FFFFFF';
                         ctx.shadowBlur = 15;
                         ctx.shadowColor = '#FFFFFF';
                     } else {
                         ctx.fillStyle = this.color;
                         ctx.shadowBlur = this.size * 2;
                         ctx.shadowColor = this.color;
                     }
                } else {
                     ctx.fillStyle = this.color;
                     ctx.shadowBlur = 10;
                     ctx.shadowColor = this.color;
                }
                ctx.fill();
            }
        }

        // --- åˆå§‹åŒ–ç³»ç»Ÿ ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }
            
            animate();
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            // æ‹–å°¾æ•ˆæœï¼šä¸å®Œå…¨æ¸…é™¤ç”»å¸ƒï¼Œè€Œæ˜¯è¦†ç›–ä¸€å±‚åŠé€æ˜é»‘è‰²
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, width, height);
            
            ctx.globalCompositeOperation = 'lighter'; // ç²’å­ä½¿ç”¨å åŠ æ··åˆæ¨¡å¼

            checkGestures(); // æ£€æŸ¥æ‰‹åŠ¿çŠ¶æ€

            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // ç»˜åˆ¶æ‰‹åŠ¿è¿æ¥çº¿ (è§†è§‰åé¦ˆ)
            ctx.globalCompositeOperation = 'source-over'; // æ¢å¤æ­£å¸¸æ¨¡å¼ç»˜åˆ¶UI
            drawHandFeedback();

            requestAnimationFrame(animate);
        }

        function checkGestures() {
            if (handLandmarks.length > 0) {
                // åªæ£€æµ‹ç¬¬ä¸€åªæ‰‹ä½œä¸ºè§¦å‘å™¨
                const hand = handLandmarks[0]; 
                const indexFinger = hand[8];
                const thumb = hand[4];
                
                // è®¡ç®—æåˆè·ç¦» (å½’ä¸€åŒ–åæ ‡)
                const pinchDist = Math.hypot(
                    indexFinger.x - thumb.x,
                    indexFinger.y - thumb.y
                );
                
                const isNowPinching = pinchDist < 0.05;

                // æ£€æµ‹æåˆå¼€å§‹ (Click)
                if (isNowPinching && !isPinching) {
                    if (systemState === STATE_CHAOS) {
                        triggerBigBang();
                    }
                }
                isPinching = isNowPinching;
            } else {
                isPinching = false;
            }
        }

        function triggerBigBang() {
            systemState = STATE_EXPLODING;
            statusText.innerText = "çŠ¶æ€: å®‡å®™å¤§çˆ†ç‚¸!!!";
            statusText.style.color = "#ff00ff";
            
            // ç»™æ‰€æœ‰ç²’å­æ–½åŠ å·¨å¤§çš„å‘å¤–çˆ†å‘åŠ›
            particles.forEach(p => {
                const dx = p.x - width / 2;
                const dy = p.y - height / 2;
                const angle = Math.atan2(dy, dx);
                const force = Math.random() * 30 + 15; // çˆ†ç‚¸åŠ›åº¦
                
                p.vx = Math.cos(angle) * force;
                p.vy = Math.sin(angle) * force;
            });

            // 2ç§’åå†·å´å½¢æˆé“¶æ²³ç³»
            setTimeout(() => {
                systemState = STATE_GALAXY;
                statusText.innerText = "çŠ¶æ€: é“¶æ²³ç³» (å¯äº¤äº’)";
                statusText.style.color = "#00ffff";
                
                // èµ‹äºˆç²’å­åˆ‡å‘é€Ÿåº¦ä»¥å½¢æˆè½¨é“
                particles.forEach(p => {
                    const dx = p.x - width / 2;
                    const dy = p.y - height / 2;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // è½¨é“é€Ÿåº¦ v = sqrt(GM/r)
                    // è°ƒæ•´å‚æ•°ä»¥è·å¾—è§†è§‰ä¸Šçš„æœ€ä½³æ•ˆæœ
                    const speed = Math.sqrt(20000 / (dist + 10)); 
                    
                    // è®¾ç½®ä¸ºåˆ‡å‘é€Ÿåº¦ (å‚ç›´äºåŠå¾„)
                    p.vx = Math.cos(angle + Math.PI / 2) * speed;
                    p.vy = Math.sin(angle + Math.PI / 2) * speed;
                    
                    // åŠ ä¸€ç‚¹éšæœºæ€§
                    p.vx += (Math.random() - 0.5) * 0.5;
                    p.vy += (Math.random() - 0.5) * 0.5;
                });
            }, 2000);
        }

        function drawHandFeedback() {
            if (handLandmarks.length > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;

                handLandmarks.forEach(hand => {
                    // ç®€å•çš„æ‰‹éƒ¨éª¨æ¶è¿æ¥
                    const connections = [
                        [8, 5], [5, 0], [0, 17], [17, 13], [13, 9], [9, 5], // æŒå¿ƒ
                        [8, 4] // é£ŸæŒ‡åˆ°æ‹‡æŒ‡ (æåˆæŒ‡ç¤º)
                    ];

                    connections.forEach(pair => {
                        const p1 = hand[pair[0]];
                        const p2 = hand[pair[1]];
                        
                        const x1 = (1 - p1.x) * width;
                        const y1 = p1.y * height;
                        const x2 = (1 - p2.x) * width;
                        const y2 = p2.y * height;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    });

                    // ç»˜åˆ¶æŒ‡å°–å…‰åœˆ
                    const indexFinger = hand[8];
                    const x = (1 - indexFinger.x) * width;
                    const y = indexFinger.y * height;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, Math.PI * 2);
                    ctx.strokeStyle = '#00ffff';
                    ctx.stroke();
                });
            }
        }

        // --- MediaPipe Hands è®¾ç½® ---
        function onResults(results) {
            loadingDiv.style.display = 'none';
            statusText.innerText = "è¿è¡Œä¸­ - æ£€æµ‹åˆ°æ‰‹åŠ¿";
            statusText.style.color = "#00ff00";

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handLandmarks = results.multiHandLandmarks;
            } else {
                handLandmarks = [];
                statusText.innerText = "è¿è¡Œä¸­ - æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                statusText.style.color = "#ffff00";
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // --- æ‘„åƒå¤´å¯åŠ¨ ---
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        camera.start()
            .then(() => {
                console.log("Camera started");
            })
            .catch(err => {
                console.error("Camera error:", err);
                statusText.innerText = "é”™è¯¯: æ— æ³•è®¿é—®æ‘„åƒå¤´";
                statusText.style.color = "red";
                loadingDiv.innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´ã€‚<br>è¯·æ£€æŸ¥æƒé™è®¾ç½®æˆ–ä½¿ç”¨ HTTPS/Localhost è®¿é—®ã€‚";
            });

        // å¯åŠ¨ç²’å­ç³»ç»Ÿ
        init();

    </script>
</body>
</html>

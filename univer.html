<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>宇宙星云手势控制系统</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505; /* 深空黑 */
        }
        canvas {
            display: block;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Segoe UI', sans-serif;
            pointer-events: none; /* 让鼠标事件穿透到 Canvas */
            user-select: none;
        }
        h1 {
            margin: 0;
            font-weight: 300;
            font-size: 1.5rem;
            letter-spacing: 2px;
        }
        p {
            font-size: 0.9rem;
            margin-top: 5px;
        }
        .highlight {
            color: #4facfe;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h1>COSMOS · INTERACTIVE</h1>
    <p>交互方式：<span class="highlight">移动</span> 推开星尘 | <span class="highlight">按住</span> 产生黑洞引力</p>
</div>

<canvas id="canvas"></canvas>

<script>
    /**
     * 配置参数
     */
    const CONFIG = {
        particleCount: 800,        // 粒子数量
        baseRadius: 1.5,           // 粒子基础大小
        connectionDistance: 100,    // 连线距离（可选，此处暂未启用以保持流畅）
        mouseRepelRadius: 150,     // 鼠标排斥半径
        mouseRepelForce: 2,        // 排斥力度
        blackHoleForce: 0.5,       // 黑洞吸力
        friction: 0.96,            // 摩擦系数 (越小停得越快)
        colors: ['#ffffff', '#4facfe', '#00f2fe', '#a8edea', '#fed6e3'] // 蓝白冷色调
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let particles = [];
    
    // 鼠标/手势状态
    const mouse = {
        x: undefined,
        y: undefined,
        isPressed: false
    };

    /**
     * 初始化画布尺寸
     */
    function initCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    /**
     * 粒子类
     */
    class Particle {
        constructor() {
            this.init();
        }

        init() {
            // 随机分布在屏幕上
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            
            // 初始随机速度
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            
            // 大小和颜色
            this.radius = Math.random() * CONFIG.baseRadius + 0.5;
            this.color = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            
            // 原始大小用于呼吸效果
            this.baseRad = this.radius;
            // 闪烁偏移
            this.angle = Math.random() * Math.PI * 2; 
        }

        update() {
            // 1. 基础物理：加上速度
            this.x += this.vx;
            this.y += this.vy;

            // 2. 摩擦力：模拟太空阻力，防止速度无限增加
            this.vx *= CONFIG.friction;
            this.vy *= CONFIG.friction;

            // 3. 自然漂浮 (如果没有外力，给一点点随机扰动)
            if (!mouse.isPressed) {
                 this.vx += (Math.random() - 0.5) * 0.02;
                 this.vy += (Math.random() - 0.5) * 0.02;
            }

            // 4. 交互逻辑
            if (mouse.x !== undefined && mouse.y !== undefined) {
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (mouse.isPressed) {
                    // === 黑洞模式 (强引力) ===
                    // 计算角度
                    const forceAngle = Math.atan2(dy, dx);
                    // 引力越近越大
                    const force = CONFIG.blackHoleForce; 
                    
                    this.vx += Math.cos(forceAngle) * force;
                    this.vy += Math.sin(forceAngle) * force;
                } else {
                    // === 挥动模式 (排斥力) ===
                    if (distance < CONFIG.mouseRepelRadius) {
                        const forceAngle = Math.atan2(dy, dx);
                        // 距离越近，推力越大
                        const forceDirection = -1; // -1 为排斥
                        const forceMagnitude = (CONFIG.mouseRepelRadius - distance) / CONFIG.mouseRepelRadius;
                        const force = forceMagnitude * CONFIG.mouseRepelForce * forceDirection;

                        this.vx += Math.cos(forceAngle) * force;
                        this.vy += Math.sin(forceAngle) * force;
                    }
                }
            }

            // 5. 边界处理 (无缝穿越)
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;

            // 6. 呼吸效果 (星星闪烁)
            this.angle += 0.05;
            this.radius = this.baseRad + Math.sin(this.angle) * 0.5;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.abs(this.radius), 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            
            // 添加光晕效果
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            
            ctx.fill();
            ctx.shadowBlur = 0; // 重置以免影响性能
        }
    }

    /**
     * 系统初始化
     */
    function init() {
        initCanvas();
        particles = [];
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle());
        }
    }

    /**
     * 动画循环
     */
    function animate() {
        // 使用半透明填充实现拖尾效果
        ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; 
        ctx.fillRect(0, 0, width, height);

        particles.forEach(p => {
            p.update();
            p.draw();
        });

        requestAnimationFrame(animate);
    }

    // === 事件监听 ===

    window.addEventListener('resize', () => {
        initCanvas();
        init(); // 重新生成粒子以适应新屏幕
    });

    window.addEventListener('mousemove', (e) => {
        mouse.x = e.x;
        mouse.y = e.y;
    });
    
    // 触摸屏支持
    window.addEventListener('touchmove', (e) => {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
    });

    window.addEventListener('mousedown', () => mouse.isPressed = true);
    window.addEventListener('mouseup', () => mouse.isPressed = false);
    
    // 触摸屏按压支持
    window.addEventListener('touchstart', () => mouse.isPressed = true);
    window.addEventListener('touchend', () => mouse.isPressed = false);

    // 鼠标移出窗口复位
    window.addEventListener('mouseout', () => {
        mouse.x = undefined;
        mouse.y = undefined;
    });

    // 启动
    init();
    animate();

</script>
</body>
</html>
